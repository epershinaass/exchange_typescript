# Авторизация

Date: 2022-07-14: PROPOSED
Date: 2022-08-01: ACCEPTED

## Status: ACCEPTED

## Context

Создать сущность для работы с credentials (учетными данными) пользователя
- Написать метод для создания токена на основе выданных данных, или возвращающий ошибку
- Написать метод создания пользователя, и вызова методов других сервисов для создания соответствующих сущностей.
- Написать метод для проверки токена


## Decision

Для проекта нужен модуль Account.

В качестве стратегии авторизации будем использовать jwt, поскольку:
1. Jwt токены содержат данные пользователя и нам не нужно будет каждый раз запрашивать эту информацию у сервера
2. Хорошая безопасность благодаря цифровой подписи
3. Быстрая проверка, ввиду того что токены не требуют поиска в базе

### Authentication
В Account будут хранится все данные пользователя, в том числе и хешированный пароль. Хешировать пароль будем на фасаде. (И на фронте, но это уже выходит за рамки данной ADR)
В дальнейшем, другие сервисы могут использовать метод `verify(token)` для того, что бы определить является ли токен валидным и не истек ли срок годности токена.
Стоит заметить что отдавать наружу внутренний id Mongo довольно опасно, поэтому будем отдавать специальный id сгенерированный с помощью uuid.
Поскольку нельзя держать секретный ключ и соль в коде, будем использовать configService для передачи параметров.
### Registration
Сервис должен передавать через Kafka сообщения содержащие id, и вызывать их методы по созданию их соответствующих бизнес сущностей.

---

Используемые технологии: Nestjs, MongoDb, Grpc, Kafka, JWT, uuid, nestjs/config.

## Alternate decisions

- Мы могли бы разделять сервис Account на Auth (аутентификация/авторизация) и User (данные пользователя):
    Пока у нас нет достаточных данных для того что бы принять решение о разделении данного микросервиса на 2.
- JWT vs Session:
    В целом для сложных решений Session больше годятся из за их гибкости, но они также и увеличивают нагрузку и заставляют писать дополнительный код.
- Мы могли бы попробовать хешировать на фронте, или же на самом сервисе Account. Но чем меньше дыр, где можно перехватить пароль - тем лучше.

```js
interface ICredentialsRequest {
  login: string;
  password: string;
}

interface IAuthMessage {
  token: string;
}

interface IUserIdRequest {
  userId: string;
}

interface IResponse {
  message: string;
}

export class Token
```

## Consequences

Последствия выбора:
- Простота реализации и простор для расширения.
- В дальнейшем придется реализовывать возможность обновления токена.
- Сложно отозвать токены, нужно писать дополнительные методы.
- Если будет украден секретный ключ, то злоумышленник может создавать свои действительные jwt и что позволит
подделать любого пользователя в приложении.
- Возможно Account быстро станет перегруженным, если перейдем с JWT на сессии.
- Возможно придется работать с коллизиями id

## Authors
https://github.com/Yura195
https://github.com/shin0kaze
https://github.com/mskuratova